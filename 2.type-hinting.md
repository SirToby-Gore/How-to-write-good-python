# Starting Questions
* What is type hinting
    - A way of declaring the type of an object, arg or return type of a function in a non-strict way

* What does it look like?
    - ether a variable or arg name followed by a `:` and the type
    - or a function name followed by `->` and the return type
    
* Who and/or what uses type hinting?
    - IDEs use it to have better detection on variable and arg types
    - It allows developers to read the code more easily
    
# Where to make type hinting 
In a python file make a new functions `add`
```python 
# python 

def add():
    ...
```

We will have it take in two arguments, `a` of type ***int*** and `b` also of type ***int***.
And it will return a the sum of the two.
```python
# python 

def add(a, b):
    return a + b
```

Let's also add some type hinting to it as well
```python
# python 

def add(a: int, b: int) -> int:
    return a + b
```

# Type hinting, a start
```python
# python

# not very clear
ambiguous_var = "1"

# better
# this also tells us that using a string is wrong
ambiguous_var: int = 1

# for a function
def ambiguous_func(ambiguous_arg):
    ...

# better
# this says that it takes in an arg of type str and returns a list with elements of type string
def ambiguous_func(ambiguous_arg: str) -> list[str]:
    ...
```

# Multiple types
You can use a pipeline `|` to type hinting on variables and return values to show multiple types possible.

```python
# python 

# for a variable
ambiguous_var: int | float = 1

# you can add lots of types
# using more than one type can be a bit confusing
# defeating the purpose of type hinting
ambiguous_var: int | float | bool = 1


# for a function
# you can not add multiple values to an args except in the following
def ambiguous_func(ambiguous_arg: str) -> list[str] | dict[int : str]:
    ...

# the exception is where you supply a default arg of a different type
def ambiguous_func(ambiguous_arg: str | None = None) -> list[str] | dict[int : str]:
    ...

# the default return value for a function in python is None
# however it is still best to deciare it so
def ambiguous_func(ambiguous_arg: str) -> None:
```

# Some types to be aware of pt.i (Generators)
```python   
# python

from typing import Generator

# Generators are functions that hold their execution state
# and can be used in for loops
# or in comprehensions in python
# to call a value from a generator you call the built in function next()
def super_secure_password_generator() -> Generator[int]:
    yield 'p'
    yield 'a'
    yield 's'
    yield 's'
    yield 'w'
    yield 'o'
    yield 'r'
    yield 'd'

    count: int = 1
    while True:
        yield count
        count += 1
        if count > 10:
            count = 0

# this is an example of comprehension 
# the type Iterable is a meta class for anything that can be iterated over
# (sets, dicts, lists, tuples, *strings*, frozenSets, etc.)
len_of_password: int = int(input('Len of password?: '))
print('Your new password is: ')
password_generator: Generator = super_secure_password_generator()
for i in range(len_of_password):
    print(next(password_generator()), end='')
```

# Some types to be aware of pt.ii (any)

```python
# python

# like how None is the default return value from a function with no return statement
# any is used as the default arg type
# use any when you want to specify that any type can be passed in or returned
def func(arg: any) -> any:
    ...
```

# Some types to be aware of pt.iii (NoReturn)

```python
# python

from typing import NoReturn

# this says that there is no re-turned value
# which often means that the return isn't None but means the program may just end
def quit_program() -> NoReturn
    from sys import exit
    exit()
```

# Some types to be aware of pt.iv (Self)
Admittedly this is not the most helpful type hinting in python but it may have its uses.

```python 
# python

class Person:

    # use the Self type to say that in a class the self keyword is of type Self 
    def __init__(self: Self, name: str, age: int, height: float) -> None:
        self.name = name
        self.age = age
        self.height = height
    
    def create_clone(self: Self) -> Self:
        return self

# You can use type hinting on classes
bob: Person = Person('bob', 20, 1.8)
mirror_of_bob: Person = bob.create_clone()
mirror_of_bob.height = 1.9
print(bob.height) # 1.9

# This happens because self is a pointer to memory addresses of the object
# So in calling mirror_of_bob.height = 1.9 you are calling at the memory address where bob's height is, set it to 1.9
```

