# Control flow
* no recursion
    + where a function calls its-self
* so do not do something like this
```python
# python

def factorial(n: int) -> int:
    if n == 1:
        return 1
    else:
        return n * factorial(n - 1)
```
* instead do this
```python
# python

def factorial(n: int) -> int:
    count: int = 0
    for i in range(1, n+1):
        count *= i
    return count 
```

# Limit all loops
* all loops should have a limit on the number of time they can be run
* it can be annoying to have to write out
```python
# python

while True:
    ...
```
- instead do this
```python
# python  

for i in range(1,000,000):
    ...
```

* this allows for code not to have run away while loops
* Or you can write it like so, if you need a while loop 
```python
# python

count: int = 0
while <condition>:
    ...
    i += 1
    if i > 1,000,000:
        break
```

# Data hiding
* declaring variables at the lowest scope possible
* no global variables
    - this should be done anyways in python with the following
    ```python
    def main() -> None:
        ...
    
    if __name__ == '__main__':
        main()
    ```
* to get the same effect as global vars use classes with self.value

# Length of readability
* functions
    - they should do 1 thing
    - and be no more than 50 lines long
* naming
    - should be most of all descriptive
    - and not too long if you can help it
    - variables
        + snake_case
        + prefix with a single `_` to show that is a variable not to be used, can be used is needed
    - constants
        + UPPER_SNAKE_CASE
        + prefix with a single `_` to show that is a constant not to be used, can be used is needed
    - functions
        + snake_case
    - classes
        + PascalCase
        + use a prefix of a double `__` to make a method or property private to the class
    - files
        + snake_case