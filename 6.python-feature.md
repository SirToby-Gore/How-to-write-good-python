# Looking at naming pt.i ( _ )

Using `_` names
You can use `_`s in names in python.
In-fact you can juts use `_` as valid name in python.
pre-fixing a variable with `_` is a good practice to note the variable as something to be discarded.

```python
# python

# prints hello 10 times
for _ in range(10):
    print('hello')
```

# Looking at naming pt.ii ( __ )

Using `__` to prefix names in python makes the method or attribute private to the class
> Public = can be accessed from out side and in the class
> Private = can only be accessed from inside the class

```python
# python

from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
    __credit_card_no: int

    def pay_for_item(self) -> None:
        # you have to use a public method to access private attributes
        return self.__credit_card_no

john: Person = Person('John', 30, 123456789)

print(john.name)
print(john.age)
print(john.__credit_card_no) # this will error

print(john.pay_for_item())
```

# Looking at naming pt.iii ( __ __, dunder methods)
Methods with `__` either side are called dunder methods.
They are called so because they are double underscores.
Dunder methods have unique aspects to a class in python.
One of the most common dunder methods is `__init__`

```python
# python

class Person:
    def __init__(self, name: str, age: int, credit_card_no: int) -> None:
        self.name = name
        self.age = age
        self.__credit_card_no = credit_card_no
```

You can also use dunder methods for other things like `__str__`

```python
# python

class Person:
    ...

    def __str__(self) -> str:
        return f'{self.name} is {self.age} years old'
```

# Slices in python pt.i (starts)
You should know how to use `[]` in python 

```python
# python 

numbers: list[int] = [1,2,3,4,5]
print(numbers[1]) # prints number "2"
```

# Slices in python pt.ii (ends)
If you add a colon in between the start and end of the slice

```python
# python

numbers: list[int] = [1,2,3,4,5]
print(numbers[1:3]) # prints 2nd and 3rd numbers [2,3]
```

# Slices in python pt.iii (Automatic values)
you do not need to supply the end number or beginning number in a slice

```python
# python

numbers: list[int] = [1,2,3,4,5]
print(numbers[:-1]) # prints all bar the last number [1,2,3,4]
print(numbers[1:]) # prints all but the first number [2,3,4,5]
```

# Slices in python pt.iv (steps)
If you add a third number you can set a step

```python
# python

numbers: list[int] = [1,2,3,4,5]
print(numbers[::-1]) # prints [5,4,3,2,1]
```

You can use a larger numbers for bigger steps

```python
# python

numbers: list[int] = [1,2,3,4,5]
print(numbers[::2]) # prints every second number [1,3,5]
```

Then add this with other slices

```python
# python

numbers: list[int] = [1,2,3,4,5]
print(numbers[1::2]) # prints from the slide of the second number then every second of that [2,4]
```

# Comprehension pt.i (lists)
Comprehensions can be useful in writing pythonic code that is faster and cleaner.

```python
# python

numbers: list[int] = [i for i in range(5)]

# Or you could have used a loop

numbers: list[int] = []
for i in range(5):
    numbers.append(i)
```

This is actually faster as in the byte code for python it has to go over every line.
In the first example python sees that there is comprehension and only has too loop for x amount of times
Where in the second example it has to go over every line, set i to next(range(5)) then check the indention level,
and then add it to the list.

# Comprehension pt.ii (lists with filters)
Comprehensions are often used to filter lists.

```python
# python

odd_numbers: list[int] = [i for i in range(10) if i % 2 == 1]

# Not so pretty
# Instead format it like this
odd_numbers: list[int] = [
    i
    for i in range(10)
    if i % 2 == 1
]

# where normally you would write

odd_numbers: list[int] = []
for i in range(10):
    if i % 2 == 1:
        odd_numbers.append(i)
```

# Comprehension pt.iii (dicts)
Comprehension can be used on other iterables shuch as dicts.

```python
# python

people: list[str] = ['john', 'wendy', 'barbra']
ages: list[int] = [12, 17, 13]

# if we know that both the ages and people are synced by index
# how would you make a dict by [name : age]

people_data: dict[str : int] = {}
for i in range(len(people)):
    people_data.update(
        {
            people[i] : ages[i]
        }
    )

# or you could use comprehension
people_data: dict[str : int] = {
    people[i] : age[i]
    for i in range(len(people))
}
```

# Comprehension pt.iv (other iters)
You can use comprehensions on more brackets than just dicts and lists.

```python
# python

# in a set there can be no duplicate values
set_of_numbers: set[int] = {i for i in range(10)}

# this would not work as 5 is already part of the set
set_of_numbers.add(5)


# tuples are immutable in python like strings
# once they are created they can not change unless under new definition
tuple_of_numbers = (i for i in range(10))

# this would not work
tuple_of_numbers[3] = 6,000

# but this would
tuple_of_numbers = (i for i in range(5000 , 5010))
```

# Comprehension pt.v (type casts)
A majority of comprehensions are used to quickly cast a list of values

```python
# python

numbers: list[str] = ['1','2','3','4','5']
numbers: list[int] = [int(i) for i in numbers]

# or it used to cast to different types of iters
```

```python
# python

tuple_of_numbers: tuple[int] = (1,2,3,4,5)
list_of_numbers: list[int] = [i for i in tuple_of_numbers]

# or you could use casting with constructors

list_of_numbers: list[int] = list(tuple_of_numbers)
``` 

# Programming paradigms pt.i (functional)
Functional programming is when you use functions to do things.
They are also not allowed to effect things outside their control flow.

valid code
```python
# python

def get_user_choice(*choices: list[str]) -> str:
    choice: str = ''
    while not choice:
        choice = input(f'Enter your choice from ({", ".join(choices)}): ')
        if choice not in choices:
            choice = ''
    return choice

def __rate_fruit_choice(choice: str) -> None:
    match choice:
        case 'apple':
            print('You chose an apple')
        case 'banana':
            print('You chose a banana')
        case 'pear':
            print('You chose a pear')
        case _:
            print(f'You chose the worst option')

def user_choice() -> None:
    choice: str = get_user_choice('apple', 'banana', 'pear')
    rate_fruit_choice(choice)

def main() -> None:
    user_choice()

if __name__ == '__main__':
    main()
```

invalid code
```python
# python

choice: str = ''    

def get_user_choice(*choices: str) -> str:
    # this is not allowed as it is not a local variable
    # FP should only effect things related to the function and not on any outer scope
    global choice

    while not choice:
        choice = input(f'Enter your choice from ({", ".join(choices)}): ')
        if choice not in choices:
            choice = ''
    return choice

def rate_fruit_choice() -> None:
    global choice
    match choice:
        case 'apple':
            print('You chose an apple')
        case 'banana':
            print('You chose a banana')
        case 'pear':
            print('You chose a pear')
        case _:
            print(f'You chose the worst option')

def user_choice() -> None:
    global choice
    choice: str = get_user_choice('apple', 'banana', 'pear')
    rate_fruit_choice()

def main() -> None:
    user_choice()

if __name__ == '__main__':
    main()
```

# Programming paradigms pt.ii (object oriented)
OOP uses classes, they are templates for a serries of methods and attributes that can be used by multiple instances of a class independently at the same time.

the above code but done in OOP

```python
# python

class User:

    # You do not have to use self at the key word here it is just the python standard
    # most languages use the keyword this
    # self refers to the object instance
    # the first argument in a classes method is always self/the object instance
    def __init__(self) -> None:
        self.choice = ''

    def user_choice(self, *choices: list[str]) -> None:
        while not self.choice:
            self.choice = input(f'Enter your choice from ({", ".join(choices)}): ')
            if self.choice not in choices:
                self.choice = ''

        match self.choice:
            case 'apple':
                print('You chose an apple')
            case 'banana':
                print('You chose a banana')
            case 'pear':
                print('You chose a pear')
            case _:
                print(f'You chose the worst option')

def main() -> None:
    you: User = User()
    you.user_choice('apple', 'banana', 'pear')

if __name__ == '__main__':
    main()
```

# Programming paradigms pt.iii (the best way to program)
The best way is to use a mix of both.
If you have smaller private methods that simplify the code.

```python
# python

from typing import Self

class User:

    # You do not have to use self at the key word here it is just the python standard
    # most languages use the keyword this
    # self refers to the object instance
    # the first argument in a classes method is always self/the object instance
    def __init__(self) -> None:
        self.choice = ''
    
    # see what I mean about this vs self
    # you do not have to use Self as a type annotation here, it just helps to show you
    def __get_user_choice(this: Self, *choices: list[str]) -> None:
        while not this.choice:
            this.choice = input(f'Enter your choice from ({", ".join(choices)}): ')
            if this.choice not in choices:
                this.choice = ''

    def __rate_fruit_choice(self) -> None:
        match self.choice:
            case 'apple':
                print('You chose an apple')
            case 'banana':
                print('You chose a banana')
            case 'pear':
                print('You chose a pear')
            case _:
                print(f'You chose the worst option')

    def user_choice(self, *choices: str) -> None:
        self.__get_user_choice(*choices)
        self.__rate_fruit_choice()

def main() -> None:
    you: User = User()
    you.user_choice('apple', 'banana', 'pear')

if __name__ == '__main__':
    main()
```

# *Args and **Kwargs
Args is short for arguments and kwargs is short for keyword arguments.

```python
# python

def loop_over_options_args(*choices: list[str]) -> str:
    print(type(choices))
    for choice in choices:
        print(choice)

# or you could do this
# it's more or else the same otherwise
def loop_over_options_list(choices: list[str]) -> str:
    print(type(choices))
    for choice in choices:
        print(choice)

loop_over_options_args('apple', 'banana', 'pear')
loop_over_options_list(['apple', 'banana', 'pear'])

# So in short the `*` is used to turn something into a list.
# But it can also do the reverse, it becomes an un-packer

args: list[str] = ['apple', 'banana', 'pear']
loop_over_options_args(*args)
```

Kwargs are used like args but for keyword arguments.

```python
# python

def make_a_pizza_kwargs(**toppings: dict[str: int]) -> None:
    print(type(toppings))
    for topping, quantity in toppings:
        print(f'{topping} has {quantity} amount')

def make_a_pizza_dict(toppings: dict[str]) -> None:
    print(type(toppings))
    for topping, quantity in toppings.items():
        print(f'{topping} has {quantity} amount')

def make_a_pizza_toppings(
    tomatoes: int = 0,
    olives: int = 0,
    anchovies: int = 0,
    pepperoni: int = 0,
    ...
)   -> None:
    # you get picture
    # you could have a really very big list of toppings where a user selected json/dict could make it easier

make_a_pizza_kwargs(
    pepperoni=1,
    olives=2,
    anchovies=3
)

make_a_pizza_dict(
    {
        'pepperoni': 1,
        'olives': 2,
        'anchovies': 3
    }
)

kwargs: dict[str: int] = {
    'pepperoni': 1,
    'olives': 2,
    'anchovies': 3
}

make_a_pizza_toppings(**kwargs)
```

# Unknown inbuilt functions pt.i (enumerate)
If like in a previous example you have list of items synced over index then you can use enumerate to get the item and its index.

```python
# python

names: list[str] = ['john', 'jane', 'bob']
ages: list[int] = [25, 30, 12]

for index, name in enumerate(names):
    print(f'{name} is aged {ages[index]}')

# you can also change the starting index value

for index, name in enumerate(names, start=1):
    print(f'{index} - {name}') 
```

# Unknown inbuilt functions pt.ii (zip)
Zip is used to combine multiple lists into a single list of tuples.

```python
# python

names: list[str] = ['john', 'jane', 'bob']
ages: list[int] = [25, 30, 12]

for name, age in zip(names, ages):
    print(f'{name} is aged {age}')

Data_2d_array: list[
    list[int]
] = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for row in Data_2d_array:
    print(row)

for column in zip(*Data_2d_array):
    print(column)
```


# Unknown inbuilt functions pt.iii (sort() and sorted())
They server the same function, to sort a list of values.

```python
# python

numbers: list[int] = [455, 322, 432, 55433, 45, 435, 53]

# Sorted is a function that returns a new list
sorted_numbers: list[int] = sorted(numbers)
print(f'{sorted_numbers=}')
print(f'{numbers=}')

# Sort is a method on the class list that works in-place
numbers.sort()
print(f'{numbers=}')
```

# How to become a master ar python
Practice something.
Don't mind what.
Feel free to ask me to review code at `W23723339@student.wsc.ac.uk`
